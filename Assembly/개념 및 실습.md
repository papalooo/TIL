




어셈블리어
===
기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다. 
컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 
따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다. 


# 이론
> ## 1.레지스터
>  ### 범용 레지스터
>  컴퓨터의 중앙처리장치(CPU) 내에 있으며 연산처리,연산결과, 복귀주소등 작은 데이터를 기억하는 레지스터 . 말 그대로 범용적으로 사용된다.
> > ### **주로 값을 저장**   
> >EAX : 산술(사칙연산), 논리연산 등을 수행하여 함수의 반환값이 저장됨.   
> >EDX : 큰 수의 곱셈과 나눗셈 연상에서 EAX 레지스터와 함께사용, 부호 확장 명령에 사용.   
> > EBX : ESI 레지스터나 EDI 레지스터와 결합가능. 메모리 주소를 저장함.   
> > ECX : 반복 명령어 사용시 반복 카운터로 사용되는 값 저장.   
> >
> > E[ ]X : 0 to 31 -> 32비트 프로세서 ( 64비트 프로세서는 e 대신 r이 붙는다. )   
> > [ ]X : 0 to 15 -> 16비트 CPU 시대때 사용. ( 이것이 확장된것이 E[ ]X 이기 때문에 호환이 가능. )   
> > [ ]H : 8 to 15 -> AX의 상위 8비트 　　　　　　ex)  [ ]X : [    이곳    |   . . . .   ]   
> > [ ]L : 0 to 7 -> AX의 하위 8비트　　　　　　　ex)  [ ]X : [   . . . .   |   이곳    ]   
> - - -
>  > ### **주로 주소를 저장**
>  > ESI : 데이터를 조작하거나 복사시에 소스데이터의 주소가 저장됨.   
>  > EDI : 복사시에 목적지의 주소가 저장됨.   
>  > ESP : 스택프레임에서 스택의 가장 끝지점 주소가 저장됨.       
>  > ※ Push Pop 명령에 따라 ESP의 값이 4바이트씩 이동함.   
>  > EBP : 스택프레임에서 스택의 시작 지점 주소가 저장됨.   
>  > ※ 스택프레임이 소멸되지 않는 이상 EBP 레지스터의 값은 변하지 않는다.   
>  > EIP : 실행할 명령어의 주소를 저장함.
    
> ## 2.주기억장치 ( 메모리 )   
> 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치   
> > *RAM ( Random Access Memory )*   
> > ---    
> > RAM 은 전원이 끊어지면 기억돼있는 데이터들이 소멸되는 휘발성 메모리이다.   
> >
> > ### RAM이 주기억장치로 쓰이는 이유
> > 하드디스크의 데이터를 RAM에 저장해서 CPU에서 이를 불러와 연산을 하게하면 처리속도가 빨라질 뿐만 아니라 하드디스크의 물리적인 움직임도 줄어들게 되기때문이다.
>    
> > **메모리 주소 지정 방식**
> > ---
> > 메모리 주소를 지정할 때 메모리 주소를 담고있는 레지스터를 이용할 수 있는데,     
> > offset을 이용하여 기존 주소에서 offset 만큼 떨어진 주소를 지정할 수 있다.    
> >
> > ex) MOV BYTE PTR DS:[EBX+0], 0　　　:　　기존 주소
> > 　　MOV BYTE PTR DS:[EBX+1], 0 　 　:　　기존 주소로부터 1 BYTE 만큼 떨어진 주소   
> > - 형식 : [base + offset + index * scale ]   
> > ※ index는 반드시 레지스터여야 하고 레지스터는 최대 2개 까지 들어갈 수 있다.
> > ex) [402000+EAX+EBX*4] , [EAX+EBX]
> 
> > ## OFFSET ( 변위차 )   
> > 현재 지점에서 일정 지점까지의 변위차를 나타내는 값    
# 개념
>##  MOV ( Move )
>	인자값을 레지스터에 덮어 씌운다.   
>
>	형식 : MOV 피연산자, 연산자   
>
> 			※ 연산자로는 메모리 주소나 레지스터, 상수값이 들어갈 수 있고,    
>			   피연산자로는 메모리 주소나 레지스터가 들어갈 수 있다.
>			[하지만 두 인자값 모두 메모리 주소가 될 수는 없다.]
> 			
> EX) 　MOV [402000], al　　|　　MOV cl, [402001]    
> 
> 
> 메모리 주소는 피연산자나 연산자의 크기에 따라 
> + DWORD PTR DS:[메모리 주소]   	=	4 BYTE
> + WORD PTR DS:[메모리 주소]   	=	2 BYTE
> + BYTE PTR DS:[메모리 주소]			= 1 BYTE   
> 
> 로 변환 된다.   
> EX)　　　　　 　　　 　[ CONVERT ]   
> 　　MOV [402000], EAX　　　->　　　MOV DWORD PTR DS:[402000], EAX   
> 　　MOV [402000], AX　 　 　-> 　　　MOV WORD PTR DS:[402000], AX   
> 　　MOV [402000], AL 　 　 　->　　　MOV BYTE PTR DS :[402000], AL   
>    
> 		※ MOV [메모리 주소], 상수값   의 형태라면 상수값을 어떤 크기로 저장할 것인지    
>			 메모리 주소 부분에서 정해야한다.     
>   
>   ## Little Endian
> Intel 은 메모리에 값을 저장할 때 Little Endian 방식을 사용하기 때문에 낮은 주소에 낮은 바이트부터 저장한다. ( Big Endian 은 그 반대 )    
> 
> 즉 저장할 값이 12 34 56 78 이라면 78 56 34 12 로 저장된다.     
>  값을 읽어올 때도 같은 방식으로 읽어오기 때문에 값이 올바르게 쓰인다.   
>
> ### 장점    
> 높거나 낮은 데이터를 추가할 때 편리함.    
- -  -
> ## NOP  ( No Operation )   
> 명령문을 실행하지 않는다.   
> 
- - -
> ## JMP ( Jump to )   
> 메모리 주소 위치로 이동하여 명령어를 순서대로 실행한다.      
> + 이동할 명령어의 위치와 현재 실행할 명령어의 위치 거리가 좁다면 short 멀다면 long     
>    
> 주소값(EIP)가 저장돼 있다면 인자값이 될 수 있다.      
> ex) JMP DWORD PTR DS:[401000]       
> 　　JMP EAX     

> ## 조건 분기 명령어 
> 조건적으로 JMP 하는 명령어   
> 
> - JZ (JE) : 상태 레지스터 Z 가 참(1) 일 때 조건이 만족한다.   
> ※ Z는 MOV 로 인해 변화하지 않는다. (intel 설계)
- - -
> ## INC, DEC ( 증감 )   
> 값을 증가/감소 시켜주는 명령어이다.   
> + INC 메모리/레지스터     
> + DEC 메모리/레지스터      
>    
> 의 형식으로 사용한다.    
> ex) INC EAX 　-　EAX(00/00/00/00) -> EAX(00/00/00/01)     
- - -
> ## ADD, SUB ( 덧셈, 뺄셈 )    
> 두 인자를 받아 첫번째 인자에 두번째 인자를 연산해준다.   
> + ADD 메모리/레지스터, 두번째 인자     
> -두 인자 모두 메모리 주소 일 순 없다.   
> 
> SUB 도 마찬가지.   
- - -
> ## CMP ( Compare , 비교 )
> 두 인자를 받아 비교하여 같으면 상태 레지스터 Z 를 1 로 변경한다.   
> ※ 두 인자를 sub(빼기) 해서 나오는 결과로 판단한다.    
> 
> ex) cmp 0,0　　-　　Z　1   
> 